# 后端开发规范文档

## 文档概述

本文档定义了后端项目的统一开发规范，涵盖Controller、Service、Mapper、Entity、DTO、VO等各层的代码标准和设计原则。所有开发人员必须遵循本规范，以确保代码的可维护性、可读性和一致性。

**核心设计原则**：
- **KISS (Keep It Simple, Stupid)**：保持简单，避免过度设计
- **YAGNI (You Aren't Gonna Need It)**：不预实现未来可能需要的功能，只实现当前需求
- **SOLID**：单一职责、开闭原则、里氏替换、接口隔离、依赖倒置

**Source**：本规范参考Spring Boot官方文档、阿里巴巴Java开发手册及行业最佳实践制定。

---

## 一、项目架构规范

### 1.1 分层架构

项目采用经典的分层架构设计，各层职责清晰、边界明确：

```
com.web408
├── controller          # 控制器层：接收HTTP请求、调用Service、返回响应
├── service            # 服务层：业务逻辑处理
│   └── impl           # 服务实现类
├── mapper             # 数据访问层：数据库操作
├── pojo               # 实体类层
│   ├── entity         # 实体类：数据库表映射
│   ├── dto            # 数据传输对象：请求/响应参数
│   └── vo             # 视图对象：返回给前端的数据
├── config             # 配置类
├── security           # 安全模块
├── utils              # 工具类
└── exception          # 异常处理
```

### 1.2 各层职责边界

| 层级       | 职责                                      | 禁止事项                     |
| ---------- | ----------------------------------------- | ---------------------------- |
| Controller | 接收请求、参数校验、调用Service、返回响应 | 业务逻辑、数据转换、文件操作 |
| Service    | 业务逻辑处理、事务管理、调用Mapper        | 直接操作HTTP请求/响应        |
| Mapper     | 数据库操作、SQL执行                       | 业务逻辑、数据处理           |
| Entity     | 数据模型映射                              | 业务逻辑、校验规则           |
| DTO        | 接口参数封装                              | 业务逻辑                     |
| VO         | 返回数据封装                              | 业务逻辑                     |

---

## 二、Controller层规范

### 2.1 设计原则

所有Controller设计严格遵循以下核心原则：
- **KISS**：Controller只负责接收请求、调用Service、返回响应
- **YAGNI**：不预设计未来可能需要的功能
- **SOLID**：单一职责原则，每个Controller只负责一个业务模块

### 2.2 核心约束

Controller层严禁包含任何业务逻辑代码：
- ❌ 数据格式转换和处理逻辑
- ❌ 文件内容生成和格式化逻辑
- ❌ 复杂的条件判断和业务规则
- ❌ 数据计算和统计逻辑
- ❌ 字符串拼接和模板处理
- ❌ 文件操作和I/O处理

Controller层只能包含：
- ✅ 接收HTTP请求参数
- ✅ 调用Service层方法
- ✅ 返回统一格式的HTTP响应
- ✅ 基础的参数校验（通过注解）
- ✅ 权限控制（通过注解）

### 2.3 基础结构规范

#### 2.3.1 导入规范

所有Controller必须在文件开头正确导入所需的类：

```java
package com.web408.controller;

import com.web408.pojo.dto.ChapterDTO;
import com.web408.pojo.vo.ApiResult;
import com.web408.pojo.vo.ChapterVO;
import com.web408.service.ChapterService;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
```

**禁止**在代码中使用完全限定类名，必须在文件开头正确导入所有使用的类。

#### 2.3.2 类级别注解

所有Controller类必须使用以下注解：

```java
@RestController
@RequestMapping("/api/{模块名}")
@Tag(name = "模块名称", description = "模块功能描述")
```

**示例**：
```java
@Tag(name = "章节管理", description = "提供章节查询和管理功能")
@RestController
@RequestMapping("/api/chapter")
public class ChapterController {
    // ...
}
```

#### 2.3.3 依赖注入规范

- **强制**使用 `@RequiredArgsConstructor` 配合 `private final` 进行构造器注入
- **禁止**使用 `@Autowired` 进行字段注入
- 禁止在Controller中直接注入Mapper
- 禁止在Controller中编写业务逻辑

```java
@RequiredArgsConstructor
public class ChapterController {

    private final ChapterService chapterService;
    // ...
}
```

### 2.4 HTTP方法使用规范

**统一规范：只使用 GET 和 POST**：
- **GET**：查询操作（查询列表、查询详情、统计等）。
- **POST**：所有变更操作（创建、更新、删除）以及复杂的查询操作。

**详细约束**：
- **创建操作**：统一使用 `POST` 方法。
- **更新操作**：统一使用 `POST` 方法，路径建议以 `/update` 结尾或直接使用资源路径。
- **删除操作**：统一使用 `POST` 方法，路径建议以 `/delete` 结尾。
- **复杂查询**：若查询参数过多（URL过长），允许使用 `POST` 方法进行查询。
- **严禁使用**：禁止使用 `PUT`、`DELETE`、`PATCH` 等其他 HTTP 方法。

**路径示例**：
- 查询列表：`GET /api/user/list`
- 查询详情：`GET /api/user/{id}`
- 创建记录：`POST /api/user`
- 更新记录：`POST /api/user/update` 或 `POST /api/user/{id}`
- 删除记录：`POST /api/user/delete` 或 `POST /api/user/{id}/delete`

### 2.5 Swagger注解规范

#### 方法级别注解（必须）

```java
@Operation(summary = "接口简要说明", description = "接口详细描述")
@ApiResponse(responseCode = "200", description = "成功")
```

#### 参数注解（必须）

```java
@Parameter(description = "参数说明", required = true, example = "示例值")
@PathVariable Long id

@Parameter(description = "参数说明", required = false)
@RequestParam(required = false) String name

@Parameter(description = "请求体说明", required = true)
@Valid @RequestBody DTO request
```

#### 权限注解

需要JWT认证的接口必须添加：
```java
@SecurityRequirement(name = "JWT")
```

需要管理员权限的接口必须添加：
```java
@PreAuthorize("hasRole('ADMIN')")
```

### 2.6 响应格式规范

所有接口必须返回 `ResponseEntity<ApiResult<T>>` 类型：

```java
// 成功响应
return ResponseEntity.ok(ApiResult.success(data, "操作成功"));

// 失败响应
return ResponseEntity.status(状态码).body(ApiResult.error(状态码, "错误信息"));
```

**HTTP状态码使用规范**：
- **200 OK**：操作成功
- **400 Bad Request**：参数错误、业务逻辑错误
- **401 Unauthorized**：未登录或认证失败
- **403 Forbidden**：无权限访问
- **404 Not Found**：资源不存在
- **500 Internal Server Error**：服务器内部错误

### 2.7 异常处理策略

**优先使用全局异常处理器**，Controller中应避免try-catch：

```java
// 推荐：依赖全局异常处理
@GetMapping("/{id}")
public ResponseEntity<ApiResult<ExamVO>> getExamById(@PathVariable Long id) {
    ExamVO exam = examService.getExamById(id);
    return ResponseEntity.ok(ApiResult.success(exam, "查询成功"));
}
```

### 2.8 参数验证规范

所有接口接收的请求体参数必须使用DTO类封装：

```java
@PostMapping
public ResponseEntity<ApiResult<ChapterVO>> createChapter(
        @Parameter(description = "章节信息", required = true)
        @Valid @RequestBody ChapterDTO request) {
    // ...
}
```

**禁止的写法**：
```java
// ❌ 禁止：直接使用Entity接收参数
@PostMapping
public ResponseEntity<ApiResult<Void>> create(@RequestBody User user) { ... }

// ❌ 禁止：使用Map接收参数
@PostMapping
public ResponseEntity<ApiResult<Void>> create(@RequestBody Map<String, Object> params) { ... }

// ❌ 禁止：缺少@Valid注解
@PostMapping
public ResponseEntity<ApiResult<Void>> create(@RequestBody RegisterDTO request) { ... }
```

### 2.9 注释规范

#### 类级别注释（必须）

```java
/**
 * 章节控制器
 * 用途：提供章节管理的RESTful API接口
 * 遵循KISS原则：简单清晰的接口设计
 */
```

#### 方法级别注释（必须）

```java
/**
 * 查询科目的启用章节树
 * 权限：公开
 */
@Operation(summary = "查询启用章节树", description = "根据科目ID查询该科目下所有启用的章节")
@GetMapping("/subject/{subjectId}")
public ResponseEntity<ApiResult<List<ChapterVO>>> getEnabledChapterTree(
        @Parameter(description = "科目ID", required = true)
        @PathVariable Long subjectId) {
    // ...
}
```

---

## 三、Service层规范

### 3.1 设计原则

- **KISS**：Service只负责业务逻辑，保持方法简洁
- **YAGNI**：不预实现未来可能需要的业务功能
- **SOLID**：单一职责，每个Service专注于一个业务领域

### 3.2 职责边界

Service层核心职责：
- 业务逻辑实现和编排
- 事务管理
- 调用Mapper层进行数据持久化
- 统一异常转换

**禁止**在Service层包含：
- HTTP请求/响应处理
- 参数校验（应由DTO注解完成）
- 直接访问前端数据

### 3.3 接口与实现分离

采用接口与实现分离的设计模式：

**接口定义**：
```java
public interface ChapterService {
    
    @Operation(summary = "根据ID查询章节", description = "查询指定ID的章节信息")
    ChapterVO getChapterById(Long id);
    
    @Operation(summary = "查询科目的章节树", description = "查询指定科目下所有启用的章节（树形结构）")
    List<ChapterVO> getChapterTreeBySubjectId(Long subjectId);
    
    @Operation(summary = "创建章节", description = "创建新章节，仅管理员可访问")
    ChapterVO createChapter(ChapterDTO chapterDTO);
    
    @Operation(summary = "更新章节", description = "更新指定ID的章节信息，仅管理员可访问")
    ChapterVO updateChapter(Long id, ChapterDTO chapterDTO);
    
    @Operation(summary = "删除章节", description = "删除指定ID的章节，仅管理员可访问")
    void deleteChapter(Long id);
}
```

**实现类**：
```java
@Service
@RequiredArgsConstructor
public class ChapterServiceImpl implements ChapterService {

    private final ChapterMapper chapterMapper;

    @Override
    public ChapterVO getChapterById(Long id) {
        Chapter chapter = chapterMapper.selectById(id);
        if (chapter == null) {
            throw new BusinessException("章节不存在");
        }
        return convertToVO(chapter);
    }
    
    // ... 其他方法实现
}
```

### 3.4 事务管理规范

#### 3.4.1 事务注解使用

使用 `@Transactional` 注解管理事务：

```java
@Service
@RequiredArgsConstructor
public class ExamServiceImpl implements ExamService {

    private final ExamMapper examMapper;

    private final ExamQuestionMapper examQuestionMapper;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public ExamVO createExam(ExamDTO examDTO, Long userId) {
        // 验证科目存在
        Subject subject = subjectMapper.selectById(examDTO.getSubjectId());
        if (subject == null) {
            throw new BusinessException("科目不存在");
        }
        
        // 创建试卷
        Exam exam = new Exam();
        exam.setSubjectId(examDTO.getSubjectId());
        exam.setTitle(examDTO.getTitle());
        exam.setDuration(examDTO.getDuration());
        exam.setTotalScore(examDTO.getTotalScore());
        exam.setCreatorId(userId);
        exam.setCreateTime(LocalDateTime.now());
        examMapper.insert(exam);
        
        // 如果有题目列表，则批量添加
        if (examDTO.getQuestionIds() != null && !examDTO.getQuestionIds().isEmpty()) {
            for (Long questionId : examDTO.getQuestionIds()) {
                ExamQuestion examQuestion = new ExamQuestion();
                examQuestion.setExamId(exam.getId());
                examQuestion.setQuestionId(questionId);
                examQuestion.setOrderNum(0);
                examQuestion.setCreateTime(LocalDateTime.now());
                examQuestionMapper.insert(examQuestion);
            }
        }
        
        return convertToVO(exam);
    }
}
```

#### 3.4.2 事务传播行为

默认使用 `REQUIRED` 传播行为，根据业务需求选择：

| 传播行为           | 适用场景                         |
| ------------------ | -------------------------------- |
| `REQUIRED`（默认） | 普通业务方法，需要事务支持       |
| `REQUIRES_NEW`     | 必须独立提交的事务（如日志记录） |
| `NESTED`           | 可以独立回滚的子事务             |
| `SUPPORTS`         | 只读查询，可以不开启事务         |

#### 3.4.3 事务回滚规则

```java
// 所有异常都回滚
@Transactional(rollbackFor = Exception.class)

// 指定异常回滚
@Transactional(rollbackFor = {BusinessException.class, DataException.class})
```

### 3.5 异常处理规范

Service层应抛出业务异常，由全局异常处理器统一处理：

```java
// 业务异常
throw new BusinessException("错误信息");

// 参数验证异常
throw new IllegalArgumentException("参数错误");
```

### 3.6 代码质量规范

#### 3.6.1 方法长度限制

- **普通方法**：不超过50行
- **复杂业务方法**：不超过100行
- **超过100行**：必须重构，拆分为多个私有方法

#### 3.6.2 参数校验

Service层方法入口必须进行参数校验：

```java
@Override
public ChapterVO updateChapter(Long id, ChapterDTO chapterDTO) {
    // 参数校验
    if (id == null) {
        throw new IllegalArgumentException("章节ID不能为空");
    }
    if (chapterDTO == null) {
        throw new IllegalArgumentException("章节信息不能为空");
    }
    
    // 业务校验
    Chapter existingChapter = chapterMapper.selectById(id);
    if (existingChapter == null) {
        throw new BusinessException("章节不存在");
    }
    
    // 业务逻辑
    // ...
}
```

#### 3.6.3 日志规范

使用 Lombok 的 `@Slf4j` 注解：

```java
@Slf4j
@Service
public class ChapterServiceImpl implements ChapterService {

    @Override
    public ChapterVO createChapter(ChapterDTO chapterDTO) {
        log.info("创建章节，请求参数：{}", chapterDTO);
        try {
            // 业务逻辑
            log.info("创建章节成功，章节ID：{}", chapter.getId());
            return convertToVO(chapter);
        } catch (Exception e) {
            log.error("创建章节失败，请求参数：{}", chapterDTO, e);
            throw e;
        }
    }
}
```

### 3.7 注释规范

#### 类注释

```java
/**
 * 章节服务实现类
 * 职责：提供章节的CRUD和树形结构查询功能
 * 遵循KISS原则：方法简洁，职责单一
 */
@Service
public class ChapterServiceImpl implements ChapterService {
    // ...
}
```

#### 方法注释

```java
/**
 * 根据ID查询章节
 * @param id 章节ID
 * @return 章节VO
 * @throws BusinessException 章节不存在时抛出
 */
@Override
public ChapterVO getChapterById(Long id) {
    // ...
}
```

---

## 四、Mapper层规范

### 4.1 设计原则

- **KISS**：Mapper只负责数据库操作，不包含业务逻辑
- **YAGNI**：不预实现未来可能需要的查询
- **SOLID**：单一职责，每个Mapper专注于一个实体类

### 4.2 命名规范

- Mapper接口：`XxxMapper.java`
- Mapper XML：`XxxMapper.xml`
- 包路径：`com.web408.mapper`

### 4.3 Mapper接口规范

```java
@Mapper
public interface ChapterMapper {
    
    @Insert("INSERT INTO chapter(subject_id, parent_id, name, order_num, enabled, create_time, update_time) " +
            "VALUES(#{subjectId}, #{parentId}, #{name}, #{orderNum}, #{enabled}, #{createTime}, #{updateTime})")
    @Options(useGeneratedKeys = true, keyProperty = "id")
    int insert(Chapter chapter);
    
    @Delete("DELETE FROM chapter WHERE id = #{id}")
    int deleteById(Long id);
    
    @Update("UPDATE chapter SET name = #{name}, order_num = #{orderNum}, update_time = #{updateTime} WHERE id = #{id}")
    int update(Chapter chapter);
    
    @Select("SELECT * FROM chapter WHERE id = #{id}")
    Chapter selectById(Long id);
    
    @Select("SELECT * FROM chapter WHERE subject_id = #{subjectId} AND enabled = true ORDER BY order_num")
    List<Chapter> selectBySubjectId(@Param("subjectId") Long subjectId);
    
    @Select("SELECT * FROM chapter WHERE subject_id = #{subjectId} ORDER BY order_num")
    List<Chapter> selectAllBySubjectId(@Param("subjectId") Long subjectId);
}
```

### 4.4 Mapper XML规范

#### 4.4.1 基础结构

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.web408.mapper.ChapterMapper">
    
    <!-- 基础结果映射 -->
    <resultMap id="BaseResultMap" type="com.web408.pojo.entity.Chapter">
        <id column="id" property="id"/>
        <result column="subject_id" property="subjectId"/>
        <result column="parent_id" property="parentId"/>
        <result column="name" property="name"/>
        <result column="order_num" property="orderNum"/>
        <result column="enabled" property="enabled"/>
        <result column="create_time" property="createTime"/>
        <result column="update_time" property="updateTime"/>
    </resultMap>
    
    <!-- 通用查询列 -->
    <sql id="Base_Column_List">
        id, subject_id, parent_id, name, order_num, enabled, create_time, update_time
    </sql>
    
    <!-- 查询方法 -->
    <select id="selectById" resultMap="BaseResultMap">
        SELECT <include refid="Base_Column_List"/>
        FROM chapter
        WHERE id = #{id}
    </select>
    
</mapper>
```

#### 4.4.2 动态SQL规范

使用 `<if>` 标签实现动态查询：

```xml
<select id="selectByCondition" resultMap="BaseResultMap">
    SELECT <include refid="Base_Column_List"/>
    FROM chapter
    <where>
        <if test="subjectId != null">
            AND subject_id = #{subjectId}
        </if>
        <if test="parentId != null">
            AND parent_id = #{parentId}
        </if>
        <if test="name != null and name != ''">
            AND name LIKE CONCAT('%', #{name}, '%')
        </if>
        <if test="enabled != null">
            AND enabled = #{enabled}
        </if>
    </where>
    ORDER BY order_num
</select>
```

#### 4.4.3 批量操作规范

```xml
<!-- 批量插入 -->
<insert id="batchInsert" useGeneratedKeys="true" keyProperty="id">
    INSERT INTO chapter (subject_id, parent_id, name, order_num, enabled, create_time, update_time)
    VALUES
    <foreach collection="list" item="item" separator=",">
        (#{item.subjectId}, #{item.parentId}, #{item.name}, #{item.orderNum}, #{item.enabled}, 
         #{item.createTime}, #{item.updateTime})
    </foreach>
</insert>

<!-- 批量更新 -->
<update id="batchUpdate">
    UPDATE chapter
    <set>
        <foreach collection="list" item="item" separator=";">
            enabled = CASE id
            <foreach collection="list" item="item">
                WHEN id = #{item.id} THEN #{item.enabled}
            </foreach>
            END
        </foreach>
    </set>
    WHERE id IN
    <foreach collection="list" item="item" open="(" separator="," close=")">
        #{item.id}
    </foreach>
</update>
```

### 4.5 性能优化规范

#### 4.5.1 索引优化

确保常用查询字段已建立索引：
- 主键自动索引
- 外键字段建立索引
- 常用查询条件字段建立索引
- 排序字段建立索引

#### 4.5.2 分页查询

使用分页插件实现分页查询：

```java
// Service层
@Override
public PageResultVO<ChapterVO> getChapterList(int page, int size, Long subjectId) {
    PageHelper.startPage(page, size);
    List<Chapter> list = chapterMapper.selectBySubjectId(subjectId);

    // 使用静态方法快速构建（推荐）
    return PageResultVO.restPage(list, chapter -> convertToVO(chapter));
}
```

#### 4.5.3 SQL优化

- 避免 SELECT *
- 使用 LIMIT 限制结果集
- 避免在 WHERE 子句中对字段进行函数运算
- 使用 EXISTS 替代 IN（子查询场景）

### 4.6 注释规范

#### 类注释

```java
/**
 * 章节Mapper接口
 * 职责：章节表的数据库操作
 * 遵循KISS原则：只负责数据访问，不包含业务逻辑
 */
@Mapper
public interface ChapterMapper {
    // ...
}
```

#### 方法注释

```java
/**
 * 根据ID查询章节
 * @param id 章节ID
 * @return 章节实体，无对应记录时返回null
 */
@Select("SELECT * FROM chapter WHERE id = #{id}")
Chapter selectById(Long id);
```

---

## 五、Entity层规范

### 5.1 设计原则

- **KISS**：Entity只负责数据模型映射，保持结构简单
- **YAGNI**：不添加与数据持久化无关的字段
- **SOLID**：单一职责，每个Entity对应一个数据库表

### 5.2 命名规范

- 类名：`PascalCase`，与数据库表名对应
- 包路径：`com.web408.pojo.entity`
- 文件名：`Xxx.java`

### 5.3 基础结构规范

#### 5.3.1 Lombok注解

```java
/**
 * 章节实体类
 * 对应数据库表：t_chapter
 * 使用 Lombok 简化代码，纯 MyBatis 数据映射
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Chapter {
    
    /** 主键ID（数据库自增） */
    private Long id;
    
    /** 所属科目ID */
    private Long subjectId;
    
    /** 父章节ID */
    private Long parentId;
    
    /** 章节名称 */
    private String name;
    
    /** 排序序号 */
    private Integer orderNum;
    
    /** 是否启用 */
    private Boolean enabled;
    
    /** 创建时间 */
    private LocalDateTime createTime;
    
    /** 更新时间 */
    private LocalDateTime updateTime;
}
```

#### 5.3.2 字段类型规范

| 数据库类型 | Java类型      | 说明       |
| ---------- | ------------- | ---------- |
| BIGINT     | Long          | 主键、外键 |
| INT        | Integer       | 整数       |
| VARCHAR    | String        | 字符串     |
| TEXT       | String        | 长文本     |
| DATETIME   | LocalDateTime | 日期时间   |
| TINYINT(1) | Boolean       | 布尔值     |
| DECIMAL    | BigDecimal    | 精确小数   |

#### 5.3.3 字段命名规范

- 主键：`id`
- 外键：`xxxId`（如 `subjectId`、`parentId`）
- 序号：`orderNum`
- 状态：`enabled`
- 时间字段：`createTime`、`updateTime`

### 5.4 特殊字段处理

#### 5.4.1 主键策略

主键策略通过 **Mapper XML** 配置实现：

```xml
<!-- 自增主键：数据库自动生成 -->
<insert id="insert" useGeneratedKeys="true" keyProperty="id">
    INSERT INTO t_chapter (subject_id, name, order_num, enabled, create_time)
    VALUES (#{subjectId}, #{name}, #{orderNum}, #{enabled}, #{createTime})
</insert>
```

**主键策略说明**：
- `useGeneratedKeys="true"`：使用数据库自增主键
- `keyProperty="id"`：将生成的主键回填到实体的 id 字段

#### 5.4.2 逻辑删除

逻辑删除在实体中增加 `deleted` 字段，在 Mapper XML 中手动处理：

```java
/** 删除标记：0-未删除，1-已删除 */
private Integer deleted;
```

```xml
<!-- 逻辑删除：更新 deleted 字段 -->
<update id="deleteLogically">
    UPDATE t_chapter SET deleted = 1 WHERE id = #{id}
</update>

<!-- 查询时排除已删除数据 -->
<select id="selectById" resultMap="BaseResultMap">
    SELECT * FROM t_chapter WHERE id = #{id} AND deleted = 0
</select>
```

#### 5.4.3 时间字段处理

时间字段在 Service 层插入时手动设置：

```java
// Service 层创建实体时设置时间
chapter.setCreateTime(LocalDateTime.now());
chapter.setUpdateTime(LocalDateTime.now());
chapterMapper.insert(chapter);

// 更新时只更新 updateTime
chapter.setUpdateTime(LocalDateTime.now());
chapterMapper.update(chapter);
```

### 5.5 注释规范

#### 类注释

```java
/**
 * 章节实体类
 * 对应数据库表：chapter
 * 用途：章节的数据模型映射
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Chapter {
    // ...
}
```

#### 字段注释

```java
/** 章节ID（主键，数据库自增） */
private Long id;

/** 所属科目ID */
private Long subjectId;

/** 父章节ID（用于树形结构，顶级章节为null） */
private Long parentId;
```

---

## 六、DTO规范

### 6.1 设计原则

- **KISS**：DTO只承载接口参数，不包含业务逻辑
- **YAGNI**：只包含当前接口需要的字段
- **SOLID**：单一职责，每个DTO对应一个具体场景

### 6.2 命名规范

- 包路径：`com.web408.pojo.dto`
- 类名：`PascalCase + DTO`
- 按场景派生：`CreateDTO`、`UpdateDTO`

### 6.3 基础结构规范

```java
@Schema(name = "章节创建请求", description = "创建新章节的请求参数")
@Data
public class ChapterDTO {
    
    @Schema(description = "所属科目ID", example = "1", requiredMode = Schema.RequiredMode.REQUIRED)
    @NotNull(message = "科目ID不能为空")
    private Long subjectId;
    
    @Schema(description = "父章节ID", example = "null", requiredMode = Schema.RequiredMode.NOT_REQUIRED)
    private Long parentId;
    
    @Schema(description = "章节名称", example = "第一章", requiredMode = Schema.RequiredMode.REQUIRED)
    @NotBlank(message = "章节名称不能为空")
    @Size(max = 100, message = "章节名称长度不能超过100个字符")
    private String name;
    
    @Schema(description = "排序序号", example = "1", requiredMode = Schema.RequiredMode.REQUIRED)
    @NotNull(message = "排序序号不能为空")
    private Integer orderNum;
    
    @Schema(description = "是否启用", example = "true", requiredMode = Schema.RequiredMode.REQUIRED)
    @NotNull(message = "启用状态不能为空")
    private Boolean enabled;
}
```

### 6.4 Lombok注解

- **必选**：`@Data`
- **视需要**：`@NoArgsConstructor`、`@AllArgsConstructor`

### 6.5 校验注解

使用 Jakarta Bean Validation 注解：

| 注解          | 适用类型 | 说明                         |
| ------------- | -------- | ---------------------------- |
| `@NotNull`    | 非字符串 | 必填字段                     |
| `@NotBlank`   | 字符串   | 字符串必填（不能为空字符串） |
| `@Size`       | 字符串   | 长度限制                     |
| `@Min`/`@Max` | 数值     | 数值范围                     |
| `@Email`      | 字符串   | 邮箱格式                     |
| `@Pattern`    | 字符串   | 正则表达式                   |

**校验消息**：必须使用中文 `message`

### 6.6 OpenAPI注解

- **类**：`@Schema(name = "中文名称", description = "用途说明")`
- **字段**：`@Schema(description = "含义", example = "示例值", required = true/false)`

### 6.7 场景派生规范

| 场景 | DTO命名        | 说明             |
| ---- | -------------- | ---------------- |
| 创建 | `XxxCreateDTO` | 创建操作专用     |
| 更新 | `XxxUpdateDTO` | 更新操作专用     |
| 通用 | `XxxDTO`       | 字段一致时可复用 |

```java
// 创建专用
@Schema(name = "章节创建请求", description = "创建新章节")
@Data
public class ChapterCreateDTO {
    // 创建所需的字段
}

// 更新专用
@Schema(name = "章节更新请求", description = "更新章节信息")
@Data
public class ChapterUpdateDTO {
    @Schema(description = "章节ID", required = true)
    @NotNull(message = "章节ID不能为空")
    private Long id;
    
    // 更新可更新的字段（可部分更新）
}
```

### 6.8 特殊类型处理

#### 6.8.1 枚举字段

短期使用 `String` 并在 `@Schema`/注释中列出：

```java
@Schema(description = "题目类型", example = "SINGLE_CHOICE", 
        allowableValues = {"SINGLE_CHOICE", "MULTIPLE_CHOICE", "TRUE_FALSE", "FILL_BLANK", "ESSAY"})
private String questionType;
```

仅在跨层复用或需强约束时抽取 `enum`：

```java
@Schema(description = "题目类型")
private QuestionType questionType;

public enum QuestionType {
    SINGLE_CHOICE("单选题"),
    MULTIPLE_CHOICE("多选题"),
    TRUE_FALSE("判断题"),
    FILL_BLANK("填空题"),
    ESSAY("问答题");
    
    private final String description;
    
    QuestionType(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}
```

#### 6.8.2 JSON字段

简单结构允许 `String` 承载 JSON：

```java
@Schema(description = "选项（JSON格式）", example = "{\"A\":\"选项1\",\"B\":\"选项2\"}")
private String options;
```

复杂场景引入专用 DTO：

```java
@Schema(description = "题目选项配置")
private QuestionOptionsDTO options;

@Schema(description = "题目选项")
@Data
public class QuestionOptionsDTO {
    @Schema(description = "A选项")
    private String A;
    
    @Schema(description = "B选项")
    private String B;
    
    @Schema(description = "C选项")
    private String C;
    
    @Schema(description = "D选项")
    private String D;
}
```

---

## 七、VO规范

### 7.1 设计原则

- **KISS**：VO只包含前端需要的字段，保持简洁
- **YAGNI**：不预实现未来可能需要的字段
- **SOLID**：单一职责，每个VO对应一个明确的视图场景

### 7.2 命名规范

- 包路径：`com.web408.pojo.vo`
- 类名：`PascalCase + VO`

### 7.3 基础结构规范

```java
@Schema(name = "章节VO", description = "章节视图对象")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ChapterVO {
    
    @Schema(description = "章节ID", example = "1")
    private Long id;
    
    @Schema(description = "所属科目ID", example = "1")
    private Long subjectId;
    
    @Schema(description = "父章节ID", example = "null")
    private Long parentId;
    
    @Schema(description = "章节名称", example = "第一章")
    private String name;
    
    @Schema(description = "排序序号", example = "1")
    private Integer orderNum;
    
    @Schema(description = "是否启用", example = "true")
    private Boolean enabled;
    
    @Schema(description = "子章节列表")
    private List<ChapterVO> children;
}
```

### 7.4 Lombok注解

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
```

**例外情况**：
- `ApiResult`：不使用Lombok，手动实现getter/setter和静态工厂方法
- `PageVO`：使用Lombok，但保留自定义构造方法

### 7.5 Swagger注解

```java
@Schema(name = "VO名称", description = "VO用途说明")
public class ExampleVO {
    
    @Schema(description = "字段说明", example = "示例值")
    private Type fieldName;
}
```

### 7.6 字段设计原则

1. **只包含前端需要的字段**：不包含数据库内部字段（如createTime、updateTime等），除非前端明确需要
2. **关联数据扁平化**：使用扁平字段（如 `subjectName`）而非嵌套对象
3. **统计字段**：统计类字段（如 `questionCount`）应在VO中明确标注
4. **树形结构**：使用 `List<SelfType> children` 字段

### 7.7 特殊VO说明

#### 7.7.1 ApiResponse<T>

- **用途**：统一API响应封装
- **特点**：不使用Lombok，提供静态工厂方法

```java
@Schema(description = "统一API响应")
public class ApiResult<T> {
    
    @Schema(description = "状态码")
    private int code;
    
    @Schema(description = "响应消息")
    private String message;
    
    @Schema(description = "响应数据")
    private T data;
    
    private ApiResult(int code, String message, T data) {
        this.code = code;
        this.message = message;
        this.data = data;
    }
    
    public static <T> ApiResult<T> success(T data, String message) {
        return new ApiResult<>(200, message, data);
    }
    
    public static <T> ApiResult<T> error(int code, String message) {
        return new ApiResult<>(code, message, null);
    }
    
    // getter/setter
}
```

#### 7.7.2 分页响应封装 (PageVO / PageResultVO)

- **用途**：统一分页响应格式。
- **命名规范**：允许使用 `PageVO<T>` 或 `PageResultVO<T>`。
- **核心字段**：必须包含 `list` (数据), `total` (总数), `page` (当前页), `size` (每页大小), `totalPages` (总页数)。

**推荐结构示例**：
```java
@Schema(name = "分页结果", description = "统一分页响应格式")
@Data
public class PageResultVO<T> {
    @Schema(description = "数据列表")
    private List<T> list;
    @Schema(description = "总记录数")
    private long total;
    @Schema(description = "当前页码")
    private int page;
    @Schema(description = "每页大小")
    private int size;
    @Schema(description = "总页数")
    private int totalPages;

    // 构造方法...
}
```

---

## 八、通用规范

### 8.1 异常处理规范

#### 8.1.1 自定义业务异常

```java
/**
 * 业务异常
 * 用于抛出业务逻辑错误
 */
public class BusinessException extends RuntimeException {
    
    private int code;
    
    public BusinessException(String message) {
        super(message);
        this.code = 400;
    }
    
    public BusinessException(int code, String message) {
        super(message);
        this.code = code;
    }
    
    public int getCode() {
        return code;
    }
}
```

#### 8.1.2 全局异常处理器

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiResult<Void>> handleBusinessException(BusinessException e) {
        return ResponseEntity.badRequest().body(ApiResult.error(e.getCode(), e.getMessage()));
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResult<Void>> handleValidationException(MethodArgumentNotValidException e) {
        String message = e.getBindingResult().getFieldErrors().stream()
                .map(FieldError::getDefaultMessage)
                .collect(Collectors.joining(", "));
        return ResponseEntity.badRequest().body(ApiResult.error(400, message));
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResult<Void>> handleException(Exception e) {
        return ResponseEntity.status(500).body(ApiResult.error(500, "系统错误，请稍后重试"));
    }
}
```

### 8.2 日志规范

#### 8.2.1 日志级别使用

| 级别  | 使用场景               |
| ----- | ---------------------- |
| DEBUG | 调试信息，开发环境使用 |
| INFO  | 正常业务日志           |
| WARN  | 警告信息，潜在问题     |
| ERROR | 错误信息，需要关注     |

#### 8.2.2 日志格式

统一使用 `@Slf4j` 注解：

```java
@Slf4j
public class ClassName {

    public void someMethod() {
        // 方法入口
        log.info("方法名开始执行，参数：{}", param);

        // 方法出口
        log.info("方法名执行成功，结果：{}", result);

        // 异常日志
        log.error("方法名执行失败，参数：{}", param, e);
    }
}
```

### 8.3 代码格式规范

#### 8.3.1 缩进与空格

- 使用4个空格缩进
- 运算符两侧各一个空格
- 逗号后一个空格

#### 8.3.2 空行规范

- 方法之间一个空行
- 不同逻辑块之间一个空行
- 类定义与第一个方法之间一个空行

#### 8.3.3 行长度

单行代码不超过120个字符

